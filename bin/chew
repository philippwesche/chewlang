#!/usr/bin/perl
# 
# This program is intended to be a high-level programming language and
# code generator with heavy emphasis on regular expressions
# and anticipated use in data scraping.
#
# It currently compiles down to Perl5.
#
# Design priorities:
# - Short, readable code
# - Ease of learning
# - Modelled after natural English usage
# - Experimental introduction of "contexts" to replace/unify flow control and parameters
#
#
# Copyright (C) 2020, 2021 Philipp L. Wesche
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License v3 (version 3),
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# To contact me, find my contact details via my personal website.

use strict;
use sigtrap;
use Getopt::Long;

my $outputProgLang = '';
GetOptions ("code=s" => \$outputProgLang);

open IN, $ARGV[0];
chomp(my @lines = <IN>);
my $preamble = "use strict;use warnings;use sigtrap;\n";
my $bracketOpener = '';
my $startingStatement = '';
my $stoppingStatement = '';
my $skippingStatement = '';
my $closingBrackets = "\n";
my $outputStatement = '';
my @vNames = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','r','s','t','u','v','w','x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'); #interim solution
my $vindex = 0;   # put some... have you seen the movie?
if ($lines[0] =~ /^Reading /) {
	#TODO we probably want to silently chop trailing white space, or warn about it
	if ($lines[0] =~ /^Reading https?\:\/\//) {
		my $url = $lines[0];
		$url =~ s/^Reading //;
		$preamble .= 'use LWP 5.64;'."\n"
			    .'my $browser = LWP::UserAgent->new;'."\n"
			    .'$browser->agent("Mozilla/5.0");'."\n"
			    .'my $url = '."'".$url."'".';'."\n"
			    .'my $res = $browser->get($url);'."\n"
			    .'die "ERROR at $url\n", $res->status_line, "\n Aborting\n" unless $res->is_success;'."\n"
			    .'my @lines = split /\n/, $res->decoded_content;'."\n"
		            .'die "Could not get $url" unless @lines;'."\n";
	} else {
		my $readfile;
		$readfile = $lines[0];
		$readfile =~ s/^Reading //;
		$preamble .=  'open IN, "'.$readfile.'";'."\n".'chomp(my @lines = <IN>);'."\n";
	}
} else {
	die 'ERROR: No "Reading" instruction found in first line.'."\n";
}
unless ($lines[@lines-1] =~ /^Output /) {
	die "ERROR: No output format specified in last line.\n";
}
unless ($lines[@lines-1] =~ /^Output tsv\+header$/) {
	die "ERROR: Specified output format not known.\n";
}
my $outputFormat;
$outputFormat = (split /^Output /, $lines[@lines-1])[1];

my $curVName = $vNames[$vindex];
$vindex++;
my $splitNum = 1;
$preamble .=    'my $processing = 0;'      ."\n"
	       .'my %capturedData;'        ."\n";
$bracketOpener .= 'for (my $'.$curVName.' = 0; $'.$curVName.' < @lines; $'.$curVName.'++) {'."\n";
$closingBrackets = '}'.$closingBrackets;

my $indentLevel = 0;
my $hasStartStatement = 0;
my $isMatchStillOpen = 0;
my %stillAllowed = ('Starting',1,'Stopping',1); # only one of each of these #TODO
my %requireOneOf = ('Starting',1,'Stopping',1,'Matching',1,'Cutting',1); #TODO
my @fieldNames;
my $regex;

# detect the indenting pattern used in the chew file
my $indentPattern = '';
my $firstIndentLine;
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s/) {
		$firstIndentLine = $i;
		my @linechars = split //, $lines[$i];
		for (my $a = 0; $a < @linechars; $a++) {
			if ($linechars[$a] =~ /\s/) {
				$indentPattern .= $linechars[$a];
			} else {
				last;
			}
		}
		last;
	}
}

# for now and for simplicity, enforce that only one whitespace character be used
my $indentLength = length($indentPattern);
my @indentSplit = split //, $indentPattern;
if ($indentLength > 1) {
	for (my $j = 1; $j < @indentSplit; $j++) {
		if ($indentSplit[$j] ne $indentSplit[$j-1]) {
			die 'ERROR: There was a mix of different whitespace characters used at the first indent, on line '.$firstIndentLine.'. Please use the same whitespace character for all indenting (space or tab, not both).'."\n";
		}
	}
}
my $indentChar = $indentSplit[0];

my @indentDepth;
for (my $i = 0; $i < @lines; $i++) {
	if ($lines[$i] =~ /^$indentChar+/) {
		my $rawIndentLen = length( substr ( $lines[$i], $-[0], $+[0]-$-[0] ) );
		if ($rawIndentLen % $indentLength) {
			die 'ERROR: Indent length on line '.($i+1).' is not a multiple of the indent length defined in the first indented line, line '.($firstIndentLine+1).".\n";
		} else {
			$indentDepth[$i] = $rawIndentLen / $indentLength;	
		}
	} else {
		$indentDepth[$i] = 0;
	}
}
#check indents are increasing only one step at a time
for (my $i = 1; $i < @lines; $i++) {
	if  ( $indentDepth[$i]  >  ( $indentDepth[$i-1] + 1 )  )  {
		die 'ERROR: Excessive indenting on line '.($i+1).'. Unexpected application behaviour may result.'."\n";
	}
}
for (my $i = 1; $i < (@lines-1); $i++) {
	if      ($lines[$i] =~ /^\s*Starting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Starting at', $lines[$i]);
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'$processing = 1;'."\n"
						   ."\t".'}'."\n"
						   ."\t".'if ($processing == 1) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			$hasStartStatement = 1;
		} else {
			die 'ERROR: Illegal end to "Starting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Stopping at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Stopping at', $lines[$i]);
			$stoppingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'last;'."\n"
						   ."\t".'}'."\n";
		} else {
			die 'ERROR: Illegal end to "Stopping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Skipping [1-9][0-9]* whenever \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = $lines[$i];
			$regex =~ s/^\s*Skipping [1-9][0-9]* whenever \///;
			$regex =~ s/\/$//;
			$regex = sanitiseRegex($regex);
			my @array = split /Skipping | whenever /, $lines[$i];
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					    ."\t\t".'$'.$curVName.' += '.$array[1].";\n"
					    ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Skipping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Matching \//) {   # probably the least useful context
						      # as Splitting can usually do its job
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Matching',$lines[$i]);
			$startingStatement .= "\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= '$processing && '
			}
			$startingStatement .= '$lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			$isMatchStillOpen = 1; # matching must be followed by cut (or take?)
		} else {
			die 'ERROR: Illegal end to "Matching" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Capture \//) {
		#TODO switch to using Take instead of Capture?
		if ($lines[$i] =~ /\/ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array1 = split /Capture \//, $lines[$i];
			my @array2 = split /\/ as /, $array1[1];
			my $regex = join '/ as ', @array2[0..(@array2-2)];
			$regex = sanitiseRegex($regex);
			push @fieldNames, $array2[$#array2];
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					     ."\t\t".'push @{ $capturedData{'.$array2[$#array2].'} }, substr($lines[$'.$curVName.'], $-[0], $+[0] - $-[0]);'."\n\t\t".'# Note about the above: the expression contained in substr()'."\n\t\t".'# is some slightly obscure Perl magic that refers to the last-matched string'."\n"
					     ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Capture" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Splitting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Splitting at',$lines[$i]);
			my $masterIndent = $indentDepth[$i];
			my $takeChunkPerlCode;
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] <= $masterIndent) {
					my @focusLines = @lines[($i+1)..($j-1)];
					my @focusIndents = @indentDepth[($i+1)..($j-1)];
					($takeChunkPerlCode, my @tempFieldNames) = processTakeChunk(($i+1), $splitNum, \@focusLines, \@focusIndents);
					push @fieldNames, @tempFieldNames;
					$i = $j-1;
					last;
				}
			}
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					     ."\t\t".'my @array'.$splitNum.' = split /'.$regex.'/, $lines[$'.$curVName.'];'."\n";
			$startingStatement .= $takeChunkPerlCode.'}';
			$splitNum++;
		} else {
			die 'ERROR: Illegal end to "Splitting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Locating around \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Locating around', $lines[$i]);
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			my $masterIndent = $indentDepth[$i];
			my $atChunkPerlCode;
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] <= $masterIndent) {
					my @focusLines = @lines[($i+1)..($j-1)];
					my @focusIndents = @indentDepth[($i+1)..($j-1)];
					($atChunkPerlCode, $splitNum, my @tempFieldNames) = processAtChunk(($i+1), $splitNum, $curVName, \@focusLines, \@focusIndents);
					$startingStatement .= $atChunkPerlCode;
					push @fieldNames, @tempFieldNames;
					$i = $j-1;
					last;
				}
			}
		} else {
			die 'ERROR: Illegal end to "Locating" statement on line '.($i+1).".\n";
		}
	} else {
		die 'ERROR: Line '.($i+1).' did not match any expected expression (Starting, Stopping, Matching, Splitting, Capture).'."\n";
	}
}

# CONSTRUCTING OUTPUT
#TODO optional warning if output columns are unbalanced
if (@fieldNames) {
	$preamble .= 'my @fieldNames = ("'.$fieldNames[0].'"';
	for (my $i = 1; $i < @fieldNames; $i++) {
		$preamble .= ',"'.$fieldNames[$i].'"';
	}
	$preamble .= ");\n";
}
my $outputStatement = 'my @outputLines;'."\n"
		     .'my $outputRowCount = 0;'."\n"
		     .'foreach (@fieldNames) {'."\n"
		     .'	if ( $outputRowCount < @{ $capturedData{$_} } ) {'."\n"
		     .'		$outputRowCount = @{ $capturedData{$_} };'."\n"
		     .'	}'."\n"
		     .'}'."\n"
		     .'for (my $i = 0; $i < $outputRowCount; $i++) {'."\n"
		     .'	$outputLines[$i] = "";'."\n"
		     .'}'."\n"
		     .'for (my $i = 0; $i < $outputRowCount; $i++) {'."\n"
		     .'	foreach (@fieldNames) {'."\n"
		     .'		if ( @{ $capturedData{$_} } ) { $outputLines[$i] .= shift @{ $capturedData{$_} } }'."\n"
		     .'		$outputLines[$i] .= "\t";'."\n"
		     .'} }'."\n"
		     .'foreach (@fieldNames) { print "$_\t" }'."\n"
		     .'print "\n";'."\n"
		     .'foreach (@outputLines) { print "$_\n" }';
my $output = $preamble.$bracketOpener.$stoppingStatement.$startingStatement.$skippingStatement.$closingBrackets.$outputStatement;
if ($outputProgLang eq 'perl5') {
	print $output;
	print "\n";
} elsif ($outputFormat eq 'tsv+header') { 
	eval $output;
}

# PARSING FUNCTIONS
sub processTakeChunk {
	my ($startLine,$splitNum,$ref1,$ref2) = @_;
	my @lines     = @$ref1;
	my @indentDepth   = @$ref2;
	my $outputVal = '';
	my @tempFieldNames;
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /^\s*Take [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array = split /Take | as /, $lines[$i];
			push @tempFieldNames, $array[2];
			$outputVal .= "\t\t".'push @{ $capturedData{'.$array[2].'} }, $array'.$splitNum.'['.$array[1].'] if defined($array'.$splitNum.'['.$array[1].']);'."\n";
		} else {
			# TODO add other possibilities, like Splitting further
			die 'ERROR: Correctly formatted Take statement expected on line '.($startLine+$i+1).".\n";
		}
	}
	return ($outputVal, @tempFieldNames);
}
sub processAtChunk {
	my ($startLine,$splitNum,$curVName,$ref1,$ref2) = @_;
	my @lines     = @$ref1;	  # making a copy
	my @indentDepth   = @$ref2;   # making a copy
	my $outputVal = '';
	my @localFieldNames;
	unless ($lines[0] =~ /^\s+At ([+-]?[1-9]\d*|0)$/) {
		die 'At statement expected on line '.($startLine+1).".\n";
	}
	for (my $i = 0; $i < @lines; $i++) {
		if ($lines[$i] =~ /^\s*(At) /) {
			my $lookWhere = $lines[$i];
			$lookWhere =~ s/^\s*At //;
			my $masterIndent = $indentDepth[$i];
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] > $masterIndent) {
					if ($lines[$j] =~ /^\s*Splitting /) {
						my $regex2 = extractRegex('Splitting at', $lines[$j]);
						my $nextMasterIndent = $indentDepth[$j];
						my $takeChunkPerlCode;
						for (my $k = $j+1; $k < @lines; $k++) {
							if ($k == $#lines) {
								my @focusLines   =       @lines[($j+1)..$k];
								my @focusIndents = @indentDepth[($j+1)..$k];
								($takeChunkPerlCode, my @tempFieldNames) = processTakeChunk(($i+1), $splitNum, \@focusLines, \@focusIndents);
								push @localFieldNames, @tempFieldNames;
								$j = $k;
								last;
							} elsif ($indentDepth[$k] <= $masterIndent) {
								my @focusLines   =       @lines[($j+1)..($k-1)];
								my @focusIndents = @indentDepth[($j+1)..($k-1)];
								($takeChunkPerlCode, my @tempFieldNames) = processTakeChunk(($i+1), $splitNum, \@focusLines, \@focusIndents);
								push @localFieldNames, @tempFieldNames;
								$j = $k - 1;
								last;
							}
						}
						my $before = "\t".'if ($lines[$'.$curVName.'+'.$lookWhere.'] =~ /'.$regex2.'/) {'."\n"
							    ."\t\t".'my @array'.$splitNum.' = split /'.$regex2.'/, $lines[$'.$curVName.'+'.$lookWhere.'];'."\n";
						my $after  = '}';
						$outputVal .= $before.$takeChunkPerlCode.$after;
						$splitNum++;
					} elsif ($lines[$i+2] =~ /^\s*Matching /) {
						#TODO
					}
				} else {
					$i = $j - 1;
					last;
				}
			}
		#} else {
			#die 'ERROR: "Locating" on line '.($i+1).' must be followed by "At" statements.'."\n";
		}
	}
	return ($outputVal,$splitNum,@localFieldNames);
}
# AUXILIARY FUNCTIONS
sub extractRegex {
	$_[1] =~ s/^\s*$_[0] \///;
	$_[1] =~ s/\/$//;
	return sanitiseRegex($_[1]);
}
sub sanitiseRegex {
	my @chars = split //, $_[0];
	if ($chars[0] eq '/') {
		$chars[0] = '\/';
	}
	my @active;
	for (my $i = 0; $i < (@chars-1); $i++) {
		if ($chars[$i] =~ /\\/ && $chars[$i+1] =~ /^\\$/) {
			$active[$i] = 0;
			$active[$i+1] = 0;
			$i++;
		} else {
			$active[$i] = 1;
		}
	}
	for (my $i = 1; $i < @chars; $i++) {
		if ($chars[$i] eq '/') {
			unless ($active[$i-1] == 1 && $chars[($i-1)] =~ /^\\$/ ) {
				$chars[$i] = '\/';
			}
		}
	}
	return (join ('', @chars));
}
