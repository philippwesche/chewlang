#!/usr/bin/perl
# 
# This program is intended to be a high-level programming language and
# code generator with heavy emphasis on regular expressions
# and anticipated use in data scraping.
#
# It currently compiles down to Perl5.
#
# Design priorities:
# - Short, readable code
# - Ease of learning
# - Modelled after natural English usage
# - Experimental introduction of "contexts" to replace/unify flow control and parameters
#
#
# Copyright (C) 2020, 2021 Philipp L. Wesche
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License v3 (version 3),
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# To contact me, find my contact details via my personal website.

use strict;
use sigtrap;
use warnings;
use Getopt::Long;

my $outputProgLang = '';
GetOptions ("code=s" => \$outputProgLang);

open IN, $ARGV[0];
chomp(my @lines = <IN>);
my $preamble = "use strict;use warnings;use sigtrap;\n";
my $bracketOpener = '';
my $startingStatement = '';
my $stoppingStatement = '';
my $skippingStatement = '';
my $closingBrackets = "}\n";
my @vNames = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','r','s','t','u','v','w','x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'); #interim solution
my $vindex = 0;   # put some... have you seen the movie?
if ($lines[0] =~ /^Reading /) {
	warn "'Reading' line contains trailing whitespace\n" if $lines[0] =~ /\s$/;
	my $url = $lines[0];
	$url =~ s/^Reading //;
	my $fileStr = expandToPerlFilelistString($url);
	if ($lines[0] =~ /^Reading https?\:\/\//) {
		$preamble .= 'use LWP 5.64;'."\n"
			    .'my $browser = LWP::UserAgent->new;'."\n"
			    .'$browser->agent("Mozilla/5.0");'."\n"
	       		    .'my %capturedData;'."\n"
			    .'foreach my $url ('.$fileStr.') {'."\n"
			    .'my $res = $browser->get($url);'."\n"
			    .'die "ERROR at $url\n", $res->status_line, "\n Aborting\n" unless $res->is_success;'."\n"
			    .'my @lines = split /\n/, $res->decoded_content;'."\n"
		            .'die "Could not get $url" unless @lines;'."\n";
	} else {
		$preamble .=  'my %capturedData;'."\n"
			     .'foreach my $file ('.$fileStr.') {'."\n"
			     .'open IN, $file;'."\n".'chomp(my @lines = <IN>);'."\n";
	}
} else {
	die 'ERROR: No "Reading" instruction found in first line.'."\n";
}
unless ($lines[@lines-1] =~ /^Output /) {
	die "ERROR: No output format specified in last line.\n";
}
unless ($lines[@lines-1] =~ /^Output tsv\+header$/) {
	die "ERROR: Specified output format not known.\n";
}
my $outputFormat;
$outputFormat = (split /^Output /, $lines[@lines-1])[1];

my $curVName = $vNames[$vindex];
$vindex++;
my $splitNum = 0;
$preamble .=    'my $processing = 0;'      ."\n";
$bracketOpener .= 'for (my $'.$curVName.' = 0; $'.$curVName.' < @lines; $'.$curVName.'++) {'."\n";
$closingBrackets = '}'.$closingBrackets;

my $indentLevel = 0;
my $hasStartStatement = 0;
my $isMatchStillOpen = 0;
my %stillAllowed = ('Starting',1,'Stopping',1); # only one of each of these #TODO
my %requireOneOf = ('Starting',1,'Stopping',1,'Matching',1,'Cutting',1); #TODO
my @fieldNames;
my $regex;

# detect the indenting pattern used in the chew file
my $indentPattern = '';
my $firstIndentLine;
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s/) {
		$firstIndentLine = $i;
		my @linechars = split //, $lines[$i];
		for (my $a = 0; $a < @linechars; $a++) {
			if ($linechars[$a] =~ /\s/) {
				$indentPattern .= $linechars[$a];
			} else {
				last;
			}
		}
		last;
	}
}

# for now and for simplicity, enforce that only one type of whitespace character be used
my $indentLength = length($indentPattern);
my @indentSplit = split //, $indentPattern;
if ($indentLength > 1) {
	for (my $j = 1; $j < @indentSplit; $j++) {
		if ($indentSplit[$j] ne $indentSplit[$j-1]) {
			die 'ERROR: There was a mix of different whitespace characters used at the first indent, on line '.$firstIndentLine.'. Please use the same whitespace character for all indenting (space or tab, not both).'."\n";
		}
	}
}
my $indentChar = $indentSplit[0];

my @indentDepth;
for (my $i = 0; $i < @lines; $i++) {
	if ($lines[$i] =~ /^$indentChar+/) {
		my $rawIndentLen = length( substr ( $lines[$i], $-[0], $+[0]-$-[0] ) );
		if ($indentLength > 0) {
			if ($rawIndentLen % $indentLength) {
				die 'ERROR: Indent length on line '.($i+1).' is not a multiple of the indent length defined in the first indented line, line '.($firstIndentLine+1).".\n";
			} else {
				$indentDepth[$i] = $rawIndentLen / $indentLength;	
			}
		} else {
			#TODO catch absence-of-indents error here, for example - or further up if fatal
		}
	} else {
		$indentDepth[$i] = 0;
	}
}
#check indents are increasing only one step at a time
for (my $i = 1; $i < @lines; $i++) {
	if  ( $indentDepth[$i]  >  ( $indentDepth[$i-1] + 1 )  )  {
		die 'ERROR: Excessive indenting on line '.($i+1).'. Unexpected application behaviour may result.'."\n";
	}
}
for (my $i = 1; $i < (@lines-1); $i++) {
	if      ($lines[$i] =~ /^\s*Starting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Starting at', $lines[$i]);
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'$processing = 1;'."\n"
						   ."\t".'}'."\n"
						   ."\t".'if ($processing == 1) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			$hasStartStatement = 1;
		} else {
			die 'ERROR: Illegal end to "Starting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Stopping at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Stopping at', $lines[$i]);
			$stoppingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'last;'."\n"
						   ."\t".'}'."\n";
		} else {
			die 'ERROR: Illegal end to "Stopping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Skipping [1-9][0-9]* whenever \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = $lines[$i];
			$regex =~ s/^\s*Skipping [1-9][0-9]* whenever \///;
			$regex =~ s/\/$//;
			$regex = sanitiseRegex($regex);
			my @array = split /Skipping | whenever /, $lines[$i];
			$startingStatement .= "\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= '$processing == 1 && '
			}
			$startingStatement .= '$lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					    ."\t\t".'$'.$curVName.' += '.$array[1].";\n"
					    ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Skipping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Matching \//) {   # probably the least useful context
						      # as Splitting can usually do its job
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Matching',$lines[$i]);
			$startingStatement .= "\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= '$processing == 1 && '
			}
			$startingStatement .= '$lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			$isMatchStillOpen = 1; # matching must be followed by cut (or take?)
		} else {
			die 'ERROR: Illegal end to "Matching" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Capture \//) {
		#TODO switch to using Take instead of Capture?
		if ($lines[$i] =~ /\/ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array1 = split /Capture \//, $lines[$i];
			my @array2 = split /\/ as /, $array1[1];
			my $regex = join '/ as ', @array2[0..(@array2-2)];
			$regex = sanitiseRegex($regex);
			push @fieldNames, $array2[$#array2];
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					     ."\t\t".'push @{ $capturedData{'.$array2[$#array2].'} }, substr($lines[$'.$curVName.'], $-[0], $+[0] - $-[0]);'."\n\t\t".'# Note about the above: the expression contained in substr()'."\n\t\t".'# is some slightly obscure Perl magic that refers to the last-matched string'."\n"
					     ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Capture" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Splitting at \//) {
		($splitNum, my $skipLines, my $startingAdd, my @tempFieldNames) = processSplit($i,$splitNum,\@lines,\@indentDepth,'lines',0);
		$startingStatement .= $startingAdd;
		push @fieldNames, @tempFieldNames;
	} elsif ($lines[$i] =~ /^\s*Locating around \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Locating around', $lines[$i]);
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			my $masterIndent = $indentDepth[$i];
			my $atChunkPerlCode;
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] <= $masterIndent) {
					($atChunkPerlCode, $splitNum, my @tempFieldNames) = processAtChunk(($i+1), $splitNum, $curVName, \@lines, \@indentDepth);
					$startingStatement .= $atChunkPerlCode;
					push @fieldNames, @tempFieldNames;
					$i = $j-1;
					last;
				}
			}
		} else {
			die 'ERROR: Illegal end to "Locating" statement on line '.($i+1).".\n";
		}
	} else {
		die 'ERROR: Line '.($i+1).' did not match any expected expression (Starting, Stopping, Matching, Splitting, Capture).'."\n";
	}
}
# CONSTRUCTING OUTPUT
#TODO optional warning if output columns are unbalanced
my $fieldnameLine = '';
if (@fieldNames) {
	$fieldnameLine .= 'my @fieldNames = ("'.$fieldNames[0].'"';
	for (my $i = 1; $i < @fieldNames; $i++) {
		$fieldnameLine .= ',"'.$fieldNames[$i].'"';
	}
	$fieldnameLine .= ");\n";
}
my $outputStatement = $fieldnameLine
		     .'my @outputLines;'."\n"
		     .'my $outputRowCount = 0;'."\n"
		     .'foreach (@fieldNames) {'."\n"
		     .'	if ( $outputRowCount < @{ $capturedData{$_} } ) {'."\n"
		     .'		$outputRowCount = @{ $capturedData{$_} };'."\n"
		     .'	}'."\n"
		     .'}'."\n"
		     .'for (my $i = 0; $i < $outputRowCount; $i++) {'."\n"
		     .'	$outputLines[$i] = "";'."\n"
		     .'}'."\n"
		     .'for (my $i = 0; $i < $outputRowCount; $i++) {'."\n"
		     .'	foreach (@fieldNames) {'."\n"
		     .'		if ( @{ $capturedData{$_} } ) { $outputLines[$i] .= shift @{ $capturedData{$_} } }'."\n"
		     .'		$outputLines[$i] .= "\t";'."\n"    #prevent column slippage by inserting tab even if no data captured for this col
		     .'} }'."\n"
		     .'foreach (@fieldNames) { print "$_\t" }'."\n"
		     .'print "\n";'."\n"
		     .'foreach (@outputLines) { print "$_\n" }';
my $output = $preamble.$bracketOpener.$stoppingStatement.$startingStatement.$skippingStatement.$closingBrackets.$outputStatement;
if ($outputProgLang eq 'perl5') {
	print $output;
	print "\n";
} elsif ($outputFormat eq 'tsv+header') { 
	eval $output;
}
# PARSING FUNCTIONS
sub processSplit {
	my ($i, $splitNum, $linep, $indentp, $cycleThrough, $lineDeviation) = @_;
	my $startingAdd = '';
	if ($$linep[$i] =~ /\/$/) {
		my $regex = extractRegex('Splitting at',$$linep[$i]);
		$splitNum++;
		my ($takeChunkPerlCode, $skipLines, @tempFieldNames) = processTakeChunk(($i+1), $splitNum, $linep, $indentp);
		my $iterationChunk;
		if ($cycleThrough eq 'lines') {
			$iterationChunk = '$'.$curVName.'+'.$lineDeviation;
		} else{
			$iterationChunk = $lineDeviation;
		}
		$startingAdd .= "\t".'if ($'.$cycleThrough.'['.$iterationChunk.'] =~ /'.$regex.'/) {'."\n"
			       ."\t\t".'my @array'.$splitNum.' = split /'.$regex.'/, $'.$cycleThrough.'['.$iterationChunk.'];'."\n"
			       . $takeChunkPerlCode.'}';
		return($splitNum,$skipLines,$startingAdd,@tempFieldNames);
	} else {
		die 'ERROR: Illegal end to "Splitting" statement on line '.($i+1).", found: $$linep[$i]\n";
	}
}
sub processTakeChunk {
	my ($startLine,$splitNum,$linep,$indentp) = @_;
	my $outputVal = '';
	my @localFieldNames;
	my $chunkLength = 0;
	for (my $i = $startLine; $i < @$linep; $i++) {
		last if ($$indentp[$i] < $$indentp[$startLine]);
		$chunkLength++;
		if ($$linep[$i] =~ /^\s*Take [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array = split /Take | as /, $$linep[$i];
			push @localFieldNames, $array[2];
			$outputVal .= "\t\t".'push @{ $capturedData{'.$array[2].'} }, $array'.$splitNum.'['.$array[1].'] if defined($array'.$splitNum.'['.$array[1].']);'."\n";
		} elsif ($$linep[$i] =~ /^\s*Taking [0-9]+$/) {	    # TODO should this be "At "? allow alternatives?
			my $wantedLine = $$linep[$i];
			$wantedLine =~ s/^\s*Taking //;
			if ($$linep[$i+1] =~ /^\s+Splitting at /) {
				($splitNum,my $splitChunkLength,my $newStartingAdd,my @tempFieldNames) = processSplit(($i+1),$splitNum,$linep,$indentp,'array'.$splitNum,$wantedLine);
				$outputVal .= $newStartingAdd;
				push @localFieldNames,@tempFieldNames;
				$i += $splitChunkLength+1;
			}
		} else {
			die 'ERROR: Correctly formatted Take statement expected on line '.($i+1).", found: $$linep[$i].\n";
		}
	}
	return ($outputVal, $chunkLength, @localFieldNames);
}
sub processAtChunk {
	my ($startLine,$splitNum,$curVName,$linep,$indentp) = @_;
	my $outputVal = '';
	my @localFieldNames;
	unless ($$linep[$startLine] =~ /^\s+At ([+-]?[1-9]\d*|0)$/) {
		die 'ERROR: At statement expected on line '.($startLine+1).".\n";
	}
	for (my $i = $startLine; $i < @$linep; $i++) {
		last if $$indentp[$i] < $$indentp[$startLine];
		if ($$linep[$i] =~ /^\s*(At) /) {
			my $lookWhere = $$linep[$i];
			$lookWhere =~ s/^\s*At //;
			for (my $j = $i+1; $j < @$linep; $j++) {
				if ($$indentp[$j] > $$indentp[$i]) {
					if ($$linep[$j] =~ /^\s*Splitting /) {
						($splitNum, my $skipLines, my $startingAdd, my @tempFieldNames) = processSplit($j,$splitNum,\@lines,\@indentDepth,'lines',$lookWhere);
						$outputVal .= $startingAdd;
			       			push @localFieldNames, @tempFieldNames;
						$j += $skipLines;
					} elsif ($$linep[$i+2] =~ /^\s*Matching /) {
						#TODO
					}
				} else {
					$i = $j - 1;
					last;
				}
			}
		} else {
			die 'ERROR: "Locating" on line '.($i+1).' must be followed by "At" statements, instead found: '."$$linep[$i]\n";
		}
	}
	return ($outputVal,$splitNum,@localFieldNames);
}
# AUXILIARY FUNCTIONS
sub extractRegex {
	$_[1] =~ s/^\s*$_[0] \///;
	$_[1] =~ s/\/$//;
	return sanitiseRegex($_[1]);
}
sub sanitiseRegex {
	my @chars = split //, $_[0];
	if ($chars[0] eq '/') {
		$chars[0] = '\/';
	}
	my @active;
	for (my $i = 0; $i < (@chars-1); $i++) {
		if ($chars[$i] =~ /\\/ && $chars[$i+1] =~ /^\\$/) {
			$active[$i] = 0;
			$active[$i+1] = 0;
			$i++;
		} else {
			$active[$i] = 1;
		}
	}
	for (my $i = 1; $i < @chars; $i++) {
		if ($chars[$i] eq '/') {
			unless ($active[$i-1] == 1 && $chars[($i-1)] =~ /^\\$/ ) {
				$chars[$i] = '\/';
			}
		}
	}
	return (join ('', @chars));
}

sub expandToPerlFilelistStringRecur {
	my @tempArray;
	my @subparts = split /\.\./, $_[0];
	my $targetLength = length($subparts[0]);
	$subparts[0] =~ s/^0+//;
	$subparts[1] =~ s/^0+//;
	if ($subparts[0] > $subparts[1]) {
		die "Read file ranges must be in ascending order.\n";
	}
	for (my $a = $subparts[0]; $a < $subparts[1]+1; $a++) {
		while ( length($a) < $targetLength ) {
			$a = "0".$a;
		}
		push @tempArray, $a.$_[1];
	}

	if (@_ > 2) {
		my @returnedList = expandToPerlFilelistStringRecur(@_[2..(@_-1)]);
		my @resultArray;
		foreach my $left (@tempArray) {
			foreach my $right (@returnedList) {
				push @resultArray, $left.$right;
			}
		}
		return @resultArray;
	} else {
		return @tempArray;
	}
}

sub expandToPerlFilelistString {
	my @variablePartsArray;
	if ($_[0] =~ /\{\{[0-9]+\.\.[0-9]+\}\}/) {
		my @parts = split /\{\{|\}\}/, $_[0];
		my @results = expandToPerlFilelistStringRecur(@parts[1..(@parts-1)]);
		my $retString = '';
		foreach my $result (@results) {
			$retString .= '"'.$parts[0].$result.'", ';
		}
		chop $retString; chop $retString;
		return $retString;
	} else {
		#TODO possible to add malformatting warnings here if the match in the first condition is not met perfectly
		return "'".$_[0]."'";
	}
}
