#!/usr/bin/perl
# 
# This program is intended to be a high-level programming language and
# code generator with heavy emphasis on regular expressions
# and anticipated use in data scraping.
#
# It currently compiles down to Perl5.
#
# Design priorities:
# - Short, readable code
# - Ease of learning
# - Modelled after natural English usage
# - Experimental introduction of "contexts" to replace/unify flow control and parameters
#
#
# Copyright (C) 2020, 2021 Philipp L. Wesche
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License v3 (version 3),
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# To contact me, find my contact details via my personal website.

use strict;
use sigtrap;
use warnings;
use Getopt::Long;

my $outputProgLang = '';
GetOptions ("code=s" => \$outputProgLang);

open IN, $ARGV[0];
chomp(my @lines = <IN>);
my $preamble1 = "use strict;use warnings;use sigtrap;\n"
	       .'use open ":std", ":encoding(UTF-8)";'."\n";
my $globalDeclarations .= 'my %capturedData;'."\n";
my $preamble2 = '';
my $bracketOpener = '';
my $startingStatement = '';
my $stoppingStatement = '';
my $skippingStatement = '';
my $dropInsert = '';
my $dropClosure = '';
my $closingBrackets = "}\n";
my @vNames = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','r','s','t','u','v','w','x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'); #interim solution
my $vindex = 0;   # put some... have you seen the movie?
if ($lines[0] =~ /^Reading /) {
	warn "'Reading' line contains trailing whitespace\n" if $lines[0] =~ /\s$/;
	my $url = $lines[0];
	$url =~ s/^Reading //;
	my $fileStr = expandToPerlFilelistString($url);
	if ($lines[0] =~ /^Reading https?\:\/\//) {
		$preamble1 .= 'use LWP 5.64;'."\n"
			     .'my $browser = LWP::UserAgent->new;'."\n"
			     .'$browser->agent("Mozilla/5.0");'."\n";
		$preamble2 .= 'my @filelist = ('.$fileStr.');'."\n"
			     .'for (my $fi = 0; $fi < @filelist; $fi++) {'."\n"
			     .'my $res = $browser->get($filelist[$fi]);'."\n"
			     .'die "ERROR at $filelist[$fi]\n", $res->status_line, "\n Aborting\n" unless $res->is_success;'."\n"
			     .'my @lines = split /\n/, $res->decoded_content;'."\n"
		             .'die "Could not fetch $filelist[$fi]\n" unless @lines;'."\n";
	} else {
		$preamble2 .= 'my @filelist = ('.$fileStr.');'."\n"
			     .'for (my $fi = 0; $fi < @filelist; $fi++) {'."\n"
			     .'open IN, $filelist[$fi];'."\n"
			     .'chomp(my @lines = <IN>);'."\n";
	}
} else {
	die 'ERROR: No "Reading" instruction found in first line.'."\n";
}

#special early exit if reframe is the last command in the file
if ($lines[@lines-1] =~ /^Reframe \//) {
	# TODO reframe with regex
} elsif ($lines[@lines-1] =~ /^Reframe$/) {
	my $earlyOutput = $preamble1.$globalDeclarations.$preamble2
			  .processReframeSimple(0).$closingBrackets;
	dispatch($outputProgLang,'tsv+header',$earlyOutput);
	exit;
}

unless ($lines[@lines-1] =~ /^Output /) {
	die "ERROR: No output format specified in last line.\n";
}
unless ($lines[@lines-1] =~ /^Output tsv\+header$/) {
	die "ERROR: Specified output format not known.\n";
}
my $outputFormat;
$outputFormat = (split /^Output /, $lines[@lines-1])[1];

my $curVName = $vNames[$vindex];
$vindex++;
my $splitNum = 0;
$preamble2 .=	   'my $processing = 0;'      ."\n";
$bracketOpener .=  'for (my $'.$curVName.' = 0; $'.$curVName.' < @lines; $'.$curVName.'++) {'."\n";
$closingBrackets = '}'.$closingBrackets;

my $indentLevel = 0;
my $hasStartStatement = 0;
my %stillAllowed = ('Starting',1,'Stopping',1); # only one of each of these #TODO
my %requireOneOf = ('Starting',1,'Stopping',1,'Matching',1,'Cutting',1); #TODO
my @fieldNames;
my $regex;

# detect the indenting pattern used in the chew file
my $indentPattern = '';
my $firstIndentLine;
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s/) {
		$firstIndentLine = $i;
		my @linechars = split //, $lines[$i];
		for (my $a = 0; $a < @linechars; $a++) {
			if ($linechars[$a] =~ /\s/) {
				$indentPattern .= $linechars[$a];
			} else {
				last;
			}
		}
		last;
	}
}

# for now and for simplicity, enforce that only one type of whitespace character be used
my $indentLength = length($indentPattern);
my @indentSplit = split //, $indentPattern;
if ($indentLength > 1) {
	for (my $j = 1; $j < @indentSplit; $j++) {
		if ($indentSplit[$j] ne $indentSplit[$j-1]) {
			die 'ERROR: There was a mix of different whitespace characters used at the first indent, on line '.$firstIndentLine.'. Please use the same whitespace character for all indenting (space or tab, not both).'."\n";
		}
	}
}
my $indentChar = $indentSplit[0];

my @indentDepth;
for (my $i = 0; $i < @lines; $i++) {
	if ($lines[$i] =~ /^$indentChar+/) {
		my $rawIndentLen = length( substr ( $lines[$i], $-[0], $+[0]-$-[0] ) );
		if ($indentLength > 0) {
			if ($rawIndentLen % $indentLength) {
				die 'ERROR: Indent length on line '.($i+1).' is not a multiple of the indent length defined in the first indented line, line '.($firstIndentLine+1).".\n";
			} else {
				$indentDepth[$i] = $rawIndentLen / $indentLength;	
			}
		} else {
			#TODO catch absence-of-indents error here, for example - or further up if fatal
		}
	} else {
		$indentDepth[$i] = 0;
	}
}
#check indents are increasing only one step at a time
for (my $i = 1; $i < @lines; $i++) {
	if  ( $indentDepth[$i]  >  ( $indentDepth[$i-1] + 1 )  )  {
		die 'ERROR: Excessive indenting on line '.($i+1).'. Unexpected application behaviour may result.'."\n";
	}
}

#pre-processing for equivalence
#TODO bring back formatting error msgs for Matching
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s*Matching \//) {
		$lines[$i] =~ s/Matching/Locating around/;
		for (my $j = $i+1; $j < (@lines-1); $j++) {
			if ($indentDepth[$j] > $indentDepth[$i]) {
				$indentDepth[$j]++;
				$lines[$j] = $indentPattern.$lines[$j];
			} else {
				last;
			}
		}
		my $insert = 'At 0';
		for (my $i = 0; $i < $indentDepth[$i]+1; $i++) {
			$insert = $indentPattern.$insert;
		}
		splice @lines, $i+1, 0, $insert;
		splice @indentDepth, $i+1, 0, $indentDepth[$i]+1;
	}
}
#main processing
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s*Reframe$/) {   # TODO reframe with regex
		$preamble2 .= processReframeSimple(1);
	} elsif      ($lines[$i] =~ /^\s*Starting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Starting at', $lines[$i]);
			$startingStatement .= "\t".'if ($processing == 0 && $lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'$processing = 1;'."\n"
						   ."\t".'}'."\n"
						   ."\t".'if ($processing == 1) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			$hasStartStatement = 1;
		} else {
			die 'ERROR: Illegal end to "Starting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Stopping at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Stopping at', $lines[$i]);
			$stoppingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'last;'."\n"
						   ."\t".'}'."\n";
		} else {
			die 'ERROR: Illegal end to "Stopping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Skipping [1-9][0-9]* whenever \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = $lines[$i];
			$regex =~ s/^\s*Skipping [1-9][0-9]* whenever \///;
			$regex =~ s/\/$//;
			$regex = sanitiseRegex($regex);
			my @array = split /Skipping | whenever /, $lines[$i];
			$startingStatement .= "\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= '$processing == 1 && '
			}
			$startingStatement .= '$lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					    ."\t\t".'$'.$curVName.' += '.$array[1].";\n"
					    ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Skipping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Capture \//) {	#TODO switch to using Take instead of Capture?
		if ($lines[$i] =~ /\/ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array1 = split /Capture \//, $lines[$i];
			my @array2 = split /\/ as /, $array1[1];
			my $regex = join '/ as ', @array2[0..(@array2-2)];
			$regex = sanitiseRegex($regex);
			checkInFieldname( \@fieldNames, $array2[$#array2] );
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					     ."\t\t".'push @{ $capturedData{'.$array2[$#array2].'} }, substr($lines[$'.$curVName.'], $-[0], $+[0] - $-[0]);'."\n\t\t".'# Note about the above: the expression contained in substr()'."\n\t\t".'# is some slightly obscure Perl magic that refers to the last-matched string'."\n"
					     ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Capture" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Splitting at \//) {
		($splitNum, my $skipLines, my $startingAdd) = processSplit(\@fieldNames, $i, $splitNum, \@lines, \@indentDepth, 'lines', 0);
		$startingStatement .= $startingAdd;
		$i += $skipLines;
	} elsif ($lines[$i] =~ /^\s*(Locating|Looking) around \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('(Locating|Looking) around', $lines[$i]);
			$startingStatement .= "\t".'if ($lines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n";
			my $masterIndent = $indentDepth[$i];
			my $atChunkPerlCode;
			for (my $j = $i+1; $j < @lines; $j++) {
				if ($indentDepth[$j] <= $masterIndent) {
					($atChunkPerlCode, $splitNum) = processAtChunk(\@fieldNames, ($i+1), $splitNum, $curVName, \@lines, \@indentDepth);
					$startingStatement .= $atChunkPerlCode.'}';
					$i = $j-1;
					last;
				}
			}
		} else {
			die 'ERROR: Illegal end to "Locating" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*(Drop|Remove|Delete|Erase) rows? (where|when|whenever|wherever) [A-Za-z][A-Za-z0-9]* matches \//) {
		if ($lines[$i] =~ /\/$/) {
			my @splitRes = split / +/, $lines[$i];
			my $wantedField = checkFieldExistsForDrop(\@fieldNames,$splitRes[3]);
			$splitRes[5] =~ s/^\///;
			$splitRes[5] =~ s/\/$//;
			my $regex = sanitiseRegex($splitRes[5]);
			$dropInsert .= '    unless ($capturedData{'.$wantedField.'}[$i] =~ /'.$regex.'/) {'."\n";
			$dropClosure .= "}\n";
		} else {
			die 'ERROR: Illegal end to "Drop", "Remove" or "Delete" statement on line '.($i+1).".\n";
		}
	} else {
		die 'ERROR: Line '.($i+1).' did not match any expected expression (Reframe, Starting, Stopping, Skipping, Matching, Locating, Splitting, Capture).'."\n";
	}
}

# CONSTRUCTING OUTPUT
my $fieldnameLine = 'my @fieldNames = (';
if (@fieldNames) {
	foreach (@fieldNames) {
		$fieldnameLine .= '"'.$_.'",';
	}
	chop $fieldnameLine;
	$fieldnameLine .= ");\n";
} else {
	die "ERROR: No valid data capture instructions found in script.\n";
}
my $outputStatement = $fieldnameLine
		     .'my @outputLines;'."\n"
		     .'my $outputRowCount = 0;'."\n"
		     .'my $warnings = "";'."\n"
		     .'foreach (@fieldNames) {'."\n"
		     .'	if ( $outputRowCount != 0 && $outputRowCount != @{ $capturedData{$_} } ) {'."\n"
		     .' 	$warnings .='."\n"
		     .'		   "WARNING: Output column \"$_\" has a different length than a previous column.\n";'."\n"
		     .'	}'."\n"
		     .'	if ( $outputRowCount < @{ $capturedData{$_} } ) {'."\n"
		     .'		$outputRowCount = @{ $capturedData{$_} };'."\n"
		     .'	}'."\n"
		     .'}'."\n"
		     .'for (my $i = 0; $i < $outputRowCount; $i++) {'."\n"
		     .$dropInsert
		     .'	$outputLines[$i] = "";'."\n"
		     .'	foreach (@fieldNames) {'."\n"
		     .'		if ( defined( ${ $capturedData{$_} }[$i] ) ) {'."\n"
		     .'			$outputLines[$i] .= ${ $capturedData{$_} }[$i];    }'."\n"
		     .'		$outputLines[$i] .= "\t";'."\n"    #prevent column slippage by inserting tab even if no data captured for this col
		     .$dropClosure
		     .'} }'."\n"
		     .'foreach (@fieldNames) { print "$_\t" }'."\n"
		     .'print "\n";'."\n"
		     .'foreach (@outputLines) { if ($_) { print "$_\n" } }'."\n"
		     .'warn $warnings if $warnings;'
		     ;
my $output = $preamble1.$globalDeclarations.$preamble2.$bracketOpener.$stoppingStatement.$startingStatement.$skippingStatement.$closingBrackets.$outputStatement;

dispatch($outputProgLang,$outputFormat,$output);

sub dispatch {
	my ($outputProgLang,$outputFormat,$output) = @_;
	if ($outputProgLang eq 'perl5') {
		print $output;
		print "\n";
	} elsif ($outputFormat eq 'tsv+header') { 
		eval $output;
	}
}
# PARSING FUNCTIONS
sub processSplit {
	my ($fieldnamep, $i, $splitNum, $linep, $indentp, $cycleThrough, $lineDeviation) = @_;
	my $startingAdd = '';
	if ($$linep[$i] =~ /\/$/) {
		my $regex = extractRegex('Splitting at',$$linep[$i]);
		my $iterationChunk;
		if ($cycleThrough eq 'lines') {
			$iterationChunk = '$'.$curVName.'+'.$lineDeviation;
		} else{
			$iterationChunk = $lineDeviation;
		}
		$splitNum++;
		$startingAdd .= "\t".'if ($'.$cycleThrough.'['.$iterationChunk.'] =~ /'.$regex.'/) {'."\n"
			       ."\t\t".'my @array'.$splitNum.' = split /'.$regex.'/, $'.$cycleThrough.'['.$iterationChunk.'];'."\n";
		($splitNum, my $takeChunkPerlCode, my $skipLines) = processTakeChunk($fieldnamep,($i+1), $splitNum, $linep, $indentp);
		$startingAdd .= $takeChunkPerlCode."\t}\n";
		return($splitNum,$skipLines,$startingAdd);
	} else {
		die 'ERROR: Illegal end to "Splitting" statement on line '.($i+1).", found: $$linep[$i]\n";
	}
}
sub processCleanChunk {
	my ($startLine,$linep,$indentp) = @_;
	my @cleanExpressions;
	my $chunkLength = 0;
	for (my $i = $startLine; $i < @$linep; $i++) {
		if ($$linep[$i] =~ /^\s+Clean \// && $$linep[$i] =~ /\/$/) {
			$chunkLength++;
			my $cleanStatement = $$linep[$i];
			$cleanStatement =~ s/^\s+Clean //;
			push @cleanExpressions, $cleanStatement;
		} else {
			return ($chunkLength, @cleanExpressions);
		}
	}
}
sub processTakeChunk {
	my ($fieldnamep,$startLine,$splitNum,$linep,$indentp) = @_;
	my $outputVal = '';
	my $chunkLength = 0;
	for (my $i = $startLine; $i < @$linep; $i++) {
		last if ($$indentp[$i] < $$indentp[$startLine]);
		$chunkLength++;
		if ($$linep[$i] =~ /^\s*Take [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array = split /Take | as /, $$linep[$i];
			checkInFieldname($fieldnamep,$array[2]);
			$outputVal .= "\t\t".'push @{ $capturedData{'.$array[2].'} }, $array'.$splitNum.'['.$array[1].'] if defined($array'.$splitNum.'['.$array[1].']);'."\n";
		} elsif ($$linep[$i] =~ /^\s*Taking [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			unless ( $$indentp[$i+1] == $$indentp[$i]+1
			      && $$linep[$i+1]   =~ /^\s+Clean \//
			      && $$linep[$i+1]   =~ /\/$/            ) {
				die 'ERROR: "Taking [...] as" on line '.$i.' must be "Take" or followed by "Clean" statement.'."\n";
			}
			my @array = split /Taking | as /, $$linep[$i];
			checkInFieldname($fieldnamep,$array[2]);
			my ($skipLines, @cleanLines) = processCleanChunk(($i+1), $linep, $indentp);
			$i += $skipLines;
			$outputVal .= "\t\t".'if (defined($array'.$splitNum.'['.$array[1].'])) {'."\n";
			foreach (@cleanLines) {
				$outputVal .= "\t\t\t".'$array'.$splitNum.'['.$array[1].'] =~ s'.$_."g;\n"; # NB substitution is currently global by default!
			}
			$outputVal .= "\t\t\t".'push @{ $capturedData{'.$array[2].'} }, $array'.$splitNum.'['.$array[1].'];'."\n\t\t}\n";
		} elsif ($$linep[$i] =~ /^\s*Taking [0-9]+$/) {	    # TODO allow "At " as an alternative?
			my $wantedLine = $$linep[$i];
			$wantedLine =~ s/^\s*Taking //;
			if ($$linep[$i+1] =~ /^\s+Splitting at /) {
				($splitNum,my $splitChunkLength,my $newStartingAdd) = processSplit($fieldnamep,($i+1),$splitNum,$linep,$indentp,'array'.$splitNum,$wantedLine);
				$outputVal .= $newStartingAdd;
				$i += $splitChunkLength+1;
			}
		} elsif ($$linep[$i] =~ /^\s*Follow [0-9]+$/) {
			# TODO switch to http(s) mode if you're in local file mode and encounter http(s) to follow
			my $findex = $$linep[$i];
			$findex =~ s/^\s*Follow //g;
			my $condInsert = '';
			my $iterInsert   = '';
			if ($$linep[$i+1] =~ /^\s+Times [0-9]*$/) {
				my $times = $$linep[$i+1];
				$times =~ s/^\s*Times //;
				$i++;
				$globalDeclarations .= 'my $followTimes = 0;'."\n";
				$condInsert .= '$followTimes < '.$times.' && ';
				$iterInsert .= "\t\t\t".'$followTimes++;'."\n";
			}
			$outputVal .= "\t\t".'if ('.$condInsert.'defined($array'.$splitNum.'['.$findex.'])) {'."\n"
				     .$iterInsert
				     ."\t\t\t".'push @filelist, $array'.$splitNum.'['.$findex.'];'."\n"
				     ."\t\t".'}'."\n";   # easier to read
		} else {
			die 'ERROR: Correctly formatted Take statement expected on line '.($i+1).", found: $$linep[$i].\n";
		}
	}
	return ($splitNum, $outputVal, $chunkLength);
}
sub processAtChunk {
	# "Locating" bracket can include Splitting, Capture, Cutting, others? 
	my ( $fieldnamep, $startLine, $splitNum, $curVName, $linep, $indentp ) = @_;
	my $outputVal = '';
	unless ($$linep[$startLine] =~ /^\s+At ([+-]?[1-9]\d*|0)$/) {
		die 'ERROR: At statement expected on line '.($startLine+1).".\n";
	}
	for (my $i = $startLine; $i < @$linep; $i++) {
		last if $$indentp[$i] < $$indentp[$startLine];
		if ($$linep[$i] =~ /^\s*(At) /) {	#TODO needs Take or Capture possibility
			my $lookWhere = $$linep[$i];
			$lookWhere =~ s/^\s*At //;
			for (my $j = $i+1; $j < @$linep; $j++) {
				if ($$indentp[$j] > $$indentp[$i]) {
					if ($$linep[$j] =~ /^\s*Splitting /) {
						($splitNum, my $skipLines, my $startingAdd) = processSplit($fieldnamep,$j,$splitNum,\@lines,\@indentDepth,'lines',$lookWhere);
						$outputVal .= $startingAdd;
						$j += $skipLines;
					}
				} else {
					$i = $j - 1;
					last;
				}
			}
		} else {
			die 'ERROR: "Locating" or "Looking" on line '.($i+1).' must be followed by "At" statements, instead found: '."$$linep[$i]\n";
		}
	}
	return ($outputVal,$splitNum);
}
sub processReframeSimple {
	my $continue = $_[0];
	my $retStr = 'my @newlines;
foreach (@lines) {
	my @array = split /\>\</, $_;
	push @newlines, $array[0].">";
	for (my $ey = 1; $ey < @array; $ey++) {
		push @newlines, "<".$array[$ey].">";
	}
	push @newlines, "<".$array[@array-1];
}'."\n";
	if ($continue) {
		return $retStr.'@lines = @newlines;'."\n";
	} else {
		return $retStr.'foreach (@newlines) { print $_."\n"; }'."\n";
	}
}
# AUXILIARY FUNCTIONS
sub extractRegex {
	$_[1] =~ s/^\s*$_[0] \///;
	$_[1] =~ s/\/$//;
	return sanitiseRegex($_[1]);
}
sub sanitiseRegex {	# makes sure there are no single / in the middle of a regex that would escape it
	my @chars = split //, $_[0];
	if ($chars[0] eq '/') {
		$chars[0] = '\/';
	}
	my @active;
	for (my $i = 0; $i < (@chars-1); $i++) {
		if ($chars[$i] =~ /\\/ && $chars[$i+1] =~ /^\\$/) {
			$active[$i] = 0;
			$active[$i+1] = 0;
			$i++;
		} else {
			$active[$i] = 1;
		}
	}
	for (my $i = 1; $i < @chars; $i++) {
		if ($chars[$i] eq '/') {
			unless ($active[$i-1] == 1 && $chars[($i-1)] =~ /^\\$/ ) {
				$chars[$i] = '\/';
			}
		}
	}
	return (join ('', @chars));
}

sub expandToPerlFilelistStringRecur {
	my @tempArray;
	my @subparts = split /\.\./, $_[0];
	my $targetLength = length($subparts[0]);
	$subparts[0] =~ s/^0+//;
	$subparts[1] =~ s/^0+//;
	if ($subparts[0] > $subparts[1]) {
		die "Read file ranges must be in ascending order.\n";
	}
	for (my $a = $subparts[0]; $a < $subparts[1]+1; $a++) {
		while ( length($a) < $targetLength ) {
			$a = "0".$a;
		}
		push @tempArray, $a.$_[1];
	}

	if (@_ > 2) {
		my @returnedList = expandToPerlFilelistStringRecur(@_[2..(@_-1)]);
		my @resultArray;
		foreach my $left (@tempArray) {
			foreach my $right (@returnedList) {
				push @resultArray, $left.$right;
			}
		}
		return @resultArray;
	} else {
		return @tempArray;
	}
}

sub expandToPerlFilelistString {
	my @variablePartsArray;
	if ($_[0] =~ /\{\{[0-9]+\.\.[0-9]+\}\}/) {
		my @parts = split /\{\{|\}\}/, $_[0];
		my @results = expandToPerlFilelistStringRecur(@parts[1..(@parts-1)]);
		my $retString = '';
		foreach my $result (@results) {
			$retString .= '"'.$parts[0].$result.'", ';
		}
		chop $retString; chop $retString;
		return $retString;
	} elsif ($_[0] =~ /\{\{|\}\}/){
		warn "ADVISORY: Double curly brackets found in URL or file name that might be incomplete syntax. Proceeding anyway.\n";
	} else {
		return "'".$_[0]."'";
	}
}

sub checkInFieldname {
	my ($fieldnamep,$value) = @_;
	foreach (@$fieldnamep) {
		if ($_ eq $value) {
			warn "WARNING: Field name $value used more than once.\n";
			return;
		}
	}
	push @$fieldnamep, $value;
}
sub checkFieldExistsForDrop {
	my ($fieldnamep,$value) = @_;
	foreach (@$fieldnamep) {
		if ($_ eq $value) {
			return $value;
		}
	}
	die "ERROR: Unknown field $value specified in drop/remove/delete condition. The field must already be known before a condition can be placed on it.\n";
}
