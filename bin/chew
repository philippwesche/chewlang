#!/usr/bin/perl
# 
# This program is intended to be a high-level programming language and
# code generator with heavy emphasis on regular expressions
# and anticipated use in data scraping.
#
# It currently compiles down to Perl5.
#
# Design priorities:
# - Short, readable code
# - Ease of learning
# - Modelled after natural English usage
# - Experimental introduction of "contexts" to replace/unify flow control and parameters
#
#
# Copyright (C) 2020, 2021 Philipp L. Wesche
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License v3 (version 3),
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#
# To contact me, find my contact details via my personal website.

use strict;
use sigtrap;
use warnings;
use Getopt::Long;

my $outputProgLang = '';
GetOptions ("code=s" => \$outputProgLang);

open IN, $ARGV[0];
chomp(my @lines = <IN>);
#remove comments and excess white space
for (my $i = 0; $i < @lines; $i++) {
	if ($lines[$i] =~ /^\s*\#/) {
		splice @lines, $i, 1;
		$i--;
	}
	#$lines[$i] =~ s/\s*\#[A-Za-z0-9\s\,\.\;\:\!\?\_\-\+\=\<\>\~\@\$\%\`\$\^\\]*$//; # rm in-line comments
	#TODO support slashes and quote marks in in-line comments; in-line comments disabled until full support
	$lines[$i] =~ s/\s*$// unless $lines[$i] =~ /^\s*Replace with /;	# rm trailing white space
}

my $preamble1 = "use strict;use warnings;use sigtrap;\n"
	       .'use open ":std", ":encoding(UTF-8)";'."\n";
my $globalDeclarations .= 'my %capturedData;'."\n";
my $preamble2 = '';
my $bracketOpener = '';
my $startingStatement = '';
my $stoppingStatement = '';
my $skippingStatement = '';
my $dropInsert = '';
my $dropClosure = '';
my $funcStr = '';
my $nonChewCode = '';
my $closingBrackets = "}\n";
my $outputFormat;
my @vNames = ('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','r','s','t','u','v','w','x','y','z','aa','ab','ac','ad','ae','af','ag','ah','ai','aj','ak','al','am','an','ao','ap'); #interim solution
my $vindex = 0;   # put some... have you seen the movie?
if ($lines[0] =~ /^Reading /) {
	warn "'Reading' line contains trailing whitespace\n" if $lines[0] =~ /\s$/;
	my $url = $lines[0];
	$url =~ s/^Reading //;
	my $fileStr = expandToPerlFilelistString($url);
	if ($lines[0] =~ /^Reading https?\:\/\//) {
		$preamble1 .= 'use LWP 5.64;'."\n"
			     .'my $chewBrowser = LWP::UserAgent->new;'."\n"
			     .'$chewBrowser->agent("Mozilla/5.0");'."\n";
		$preamble2 .= 'my @fileList = ('.$fileStr.');'."\n"
			     .'for (my $fi = 0; $fi < @fileList; $fi++) {'."\n"
			     .'my @chewLines = chewURLlines($chewBrowser,$fileList[$fi]);'."\n"
		             .'die "Could not fetch $fileList[$fi]\n" unless @chewLines;'."\n";
		$funcStr   .= 'sub chewURLlines {'."\n"
			     ."\t".'my $res = $_[0]->get($_[1]);'."\n"
			     ."\t".'die "ERROR at $_[1]\n", $res->status_line, "\n Aborting\n" unless $res->is_success;'."\n"
			     ."\t".'return (split (/\n/, $res->decoded_content));'."\n"
			     .'}'."\n";
	} else {
		$preamble2 .= 'my @fileList = ('.$fileStr.');'."\n"
			     .'for (my $fi = 0; $fi < @fileList; $fi++) {'."\n"
			     .'open IN, $fileList[$fi];'."\n"
			     .'chomp(my @chewLines = <IN>);'."\n";
	}
} else {
	die 'ERROR: No "Reading" instruction found in first line.'."\n";
}

#special early exit if reframe is the last command in the file
if ($lines[@lines-1] =~ /^Reframe \//) {
	# TODO make it safer
	my $regex = $lines[@lines-1];
	$regex =~ s/^\s*Reframe //;
	my $earlyOutput = $preamble1.$globalDeclarations.$preamble2
			  .processReframe(0,$regex).$closingBrackets;
	dispatch($outputProgLang,'tsv+header',$earlyOutput);
	exit;
} elsif ($lines[@lines-1] =~ /^Reframe$/) {
	my $earlyOutput = $preamble1.$globalDeclarations.$preamble2
			  .processReframe(0,'/\>\</>\n</').$closingBrackets;
	dispatch($outputProgLang,'tsv+header',$earlyOutput);
	exit;
}

#checking output conditions are defined
#TODO enable and allow multiple outputs
if ($lines[@lines-1] =~ /^Output /) {
	for (my $i = 1; $i < @lines; $i++) {
		if ($lines[$i] =~ /^Outputting /) {
			die 'ERROR: Both Output and Outputting specified. Unclear what you want.'."\n";
		}
	}
} elsif ($lines[@lines-2] =~ /^Outputting /) {
} else {
	for (my $i = 1; $i < @lines; $i++) {
		if ($lines[$i] =~ /^Hand-over$/i) {
			$nonChewCode = join ("\n", @lines[($i+1)..(@lines-1)]);
			splice @lines, $i+1, (@lines-$i);   # removing non-chew lines early to avoid errors later
			last;
		}
		if ($i == (@lines-1)) {
			die "ERROR: Neither output format nor hand-over were specified. Must have at least one.\n";
		}
	}
}

my $curVName = $vNames[$vindex];
$vindex++;
my $splitNum = 0;
$preamble2 .=	   'my $processing = 0;'      ."\n";
$bracketOpener .=  'for (my $'.$curVName.' = 0; $'.$curVName.' < @chewLines; $'.$curVName.'++) {'."\n";
$closingBrackets = '}'.$closingBrackets;

my $indentLevel = 0;
my $hasStartStatement = 0;
my %stillAllowed = ('Starting',1,'Stopping',1); # only one of each of these #TODO
my %requireOneOf = ('Starting',1,'Stopping',1,'Matching',1,'Cutting',1); #TODO
my @fieldNames;
my $regex;

# detect the indenting pattern used in the chew file
my $indentPattern = '';
my $firstIndentLine;
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s/) {
		$firstIndentLine = $i;
		my @linechars = split //, $lines[$i];
		for (my $a = 0; $a < @linechars; $a++) {
			if ($linechars[$a] =~ /\s/) {
				$indentPattern .= $linechars[$a];
			} else {
				last;
			}
		}
		last;
	}
}

# for now and for simplicity, enforce that only one type of whitespace character be used
my $indentLength = length($indentPattern);
my @indentSplit = split //, $indentPattern;
if ($indentLength > 1) {
	for (my $j = 1; $j < @indentSplit; $j++) {
		if ($indentSplit[$j] ne $indentSplit[$j-1]) {
			die 'ERROR: There was a mix of different whitespace characters used at the first indent, on line '.$firstIndentLine.'. Please use the same whitespace character for all indenting (space or tab, not both).'."\n";
		}
	}
}
my $indentChar = $indentSplit[0];

my @indentDepth;
for (my $i = 0; $i < @lines; $i++) {
	if ($lines[$i] =~ /^$indentChar+/) {
		my $rawIndentLen = length( substr ( $lines[$i], $-[0], $+[0]-$-[0] ) );
		if ($indentLength > 0) {
			if ($rawIndentLen % $indentLength) {
				die 'ERROR: Indent length on line '.($i+1).' is not a multiple of the indent length defined in the first indented line, line '.($firstIndentLine+1).".\n";
			} else {
				$indentDepth[$i] = $rawIndentLen / $indentLength;	
			}
		} else {
			#TODO catch absence-of-indents error here, for example - or further up if fatal
		}
	} else {
		$indentDepth[$i] = 0;
	}
}
#check indents are increasing only one step at a time
for (my $i = 1; $i < @lines; $i++) {
	if  ( $indentDepth[$i]  >  ( $indentDepth[$i-1] + 1 )  )  {
		die 'ERROR: Excessive indenting on line '.($i+1).'. Unexpected application behaviour may result.'."\n";
	}
}

#pre-processing for equivalence
for (my $i = 1; $i < (@lines-1); $i++) {
	if ($lines[$i] =~ /^\s*Matching \//) {
		die 'ERROR: Illegal end to "Matching" statement on line '.($i+1).", found: $lines[$i]\n" unless ($lines[$i] =~ /\/$/) {
		$lines[$i] =~ s/Matching/Locating around/;
		for (my $j = $i+1; $j < (@lines-1); $j++) {
			if ($indentDepth[$j] > $indentDepth[$i]) {
				$indentDepth[$j]++;
				$lines[$j] = $indentPattern.$lines[$j];
			} else {
				last;
			}
		}
		my $insert = 'At 0';
		for (my $i = 0; $i < $indentDepth[$i]+1; $i++) {
			$insert = $indentPattern.$insert;
		}
		splice @lines, $i+1, 0, $insert;
		splice @indentDepth, $i+1, 0, $indentDepth[$i]+1;
	}
}
#main processing
for (my $i = 1; $i < @lines; $i++) {
	if ($lines[$i] =~ /^\s*Reframe \//) {
		# TODO make it safer
		my $regex = $lines[$i];
		$regex =~ s/^\s*Reframe //;
		$preamble2 .= processReframe(1,$regex);
	} elsif ($lines[$i] =~ /^\s*Reframe$/) {
		$preamble2 .= processReframe(1,'/\>\</>\n</');
	} elsif      ($lines[$i] =~ /^\s*Starting at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Starting at', $lines[$i]);
			$startingStatement .= "\t".'if ($processing == 0 && $chewLines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'$processing = 1;'."\n"
						   ."\t".'}'."\n"
						   ."\t".'if ($processing == 1) {'."\n";
			$closingBrackets = '}'.$closingBrackets;
			$hasStartStatement = 1;
		} else {
			die 'ERROR: Illegal end to "Starting" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Stopping at \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('Stopping at', $lines[$i]);
			$stoppingStatement .= "\t".'if ($chewLines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
						   ."\t\t".'last;'."\n"
						   ."\t".'}'."\n";
		} else {
			die 'ERROR: Illegal end to "Stopping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Skipping [1-9][0-9]* whenever \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = $lines[$i];
			$regex =~ s/^\s*Skipping [1-9][0-9]* whenever \///;
			$regex =~ s/\/$//;
			$regex = sanitiseRegex($regex);
			my @array = split /Skipping | whenever /, $lines[$i];
			$startingStatement .= "\t".'if (';
			if ($hasStartStatement) {
				$startingStatement .= '$processing == 1 && '
			}
			$startingStatement .= '$chewLines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					    ."\t\t".'$'.$curVName.' += '.$array[1].";\n"
					    ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Skipping" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*Capture \//) {
		#TODO Capture needs Clean
		#TODO make it capture all matching strings on a given line, not just the first one
		#     then offer the option to catch only one, or otherwise limit catching (e.g. once per page)
		#TODO also offer Capture as an option within Split and Locating contexts (just like Cutting)
		if ($lines[$i] =~ /\/ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array1 = split /Capture \//, $lines[$i];
			my @array2 = split /\/ as /, $array1[1];
			my $regex = join '/ as ', @array2[0..(@array2-2)];
			die 'ERROR: Empty "Capture" search expression on line '.($i+1).".\n" unless $regex;
			$regex = sanitiseRegex($regex);
			checkInFieldname( \@fieldNames, $array2[$#array2] );
			$startingStatement .= "\t".'if ($chewLines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n"
					     ."\t\t".'$chewFieldInitiations{'.$array2[$#array2].'}++;'."\n"
					     ."\t\t".'push @{ $capturedData{'.$array2[$#array2].'} }, substr($chewLines[$'.$curVName.'], $-[0], $+[0] - $-[0]);'."\n\t\t".'# Note about the above: the expression contained in substr()'."\n\t\t".'# is some slightly obscure Perl magic that refers to the last-matched string'."\n"
					     ."\t}\n";
		} else {
			die 'ERROR: Illegal end to "Capture" statement on line '.($i+1).", found: $lines[$i]\n";
		}
	} elsif ($lines[$i] =~ /^\s*Splitting at \//) {
		($splitNum, my $skipLines, my $startingAdd) = processSplit(\@fieldNames, $i, $splitNum, \@lines, \@indentDepth, 'chewLines', 0);
		$startingStatement .= $startingAdd;
		$i += $skipLines;
	} elsif ($lines[$i] =~ /^\s*(Locating|Looking) around \//) {
		if ($lines[$i] =~ /\/$/) {
			my $regex = extractRegex('(Locating|Looking) around', $lines[$i]);
			$startingStatement .= "\t".'if ($chewLines[$'.$curVName.'] =~ /'.$regex.'/) {'."\n";
			my $masterIndent = $indentDepth[$i];
			my $atChunkPerlCode;
			if ($i < (@lines-1) ) {
				for (my $j = $i+1; $j < @lines; $j++) {
					if ($indentDepth[$j] <= $masterIndent) {
						($atChunkPerlCode, $splitNum) = processAtChunk(\@fieldNames, ($i+1), $splitNum, $curVName, \@lines, \@indentDepth);
						$startingStatement .= $atChunkPerlCode.'}';
						$i = $j-1;
						last;
					}
				}
			}
		} else {
			die 'ERROR: Illegal end to "Locating" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^\s*(Drop|Remove|Delete|Erase) rows? (where|when|whenever|wherever) [A-Za-z][A-Za-z0-9]* matches \//) {
		if ($lines[$i] =~ /\/$/) {
			my @splitRes = split / +/, $lines[$i];
			my $wantedField = checkFieldExistsForDrop(\@fieldNames,$splitRes[3]);
			$splitRes[5] =~ s/^\///;
			$splitRes[5] =~ s/\/$//;
			my $regex = sanitiseRegex($splitRes[5]);
			$dropInsert .= '    unless ($capturedData{'.$wantedField.'}[$i] =~ /'.$regex.'/) {'."\n";
			$dropClosure .= "}\n";
		} else {
			die 'ERROR: Illegal end to "Drop", "Remove" or "Delete" statement on line '.($i+1).".\n";
		}
	} elsif ($lines[$i] =~ /^Hand-over$/i) {
		last;
	} elsif ($lines[$i] =~ /^Output /i) {
		$outputFormat = (split /^Output /, $lines[$i])[1];
		unless ($outputFormat eq 'tsv+header') {
			die "ERROR: Specified output format not known on line ".($i+1).".\n";
		}
		$globalDeclarations .= 'my @fieldNames = (';
		if (@fieldNames) {
			foreach (@fieldNames) {
				$globalDeclarations .= '"'.$_.'",';
			}
			chop $globalDeclarations;
			$globalDeclarations .= ');'."\n".'my %chewFieldInitiations;'."\n".'foreach (@fieldNames) { $chewFieldInitiations{$_} = 0; }'."\n";
		} else {
			die "ERROR: No valid data capture instructions found in script.\n";
		}
	} elsif ($lines[$i] =~ /^Outputting /i) {
		$outputFormat = (split /^Outputting /, $lines[$i])[1];
		unless ($outputFormat eq 'tsv+header') {
			die "ERROR: Specified output format not known on line ".($i+1).".\n";
		}
		if ($i < (@lines-1)) {
			if ($lines[$i+1] =~ /^\s*Order /) {
				my $orderline = $lines[$i+1];
				$orderline =~ s/^\s*Order //;
				my @order = split /\s*\,\s*/, $orderline;
KAYA:				for (my $kaya = 0; $kaya < @fieldNames; $kaya++) {
					for (my $jayden = 0; $jayden < @order; $jayden++) {
						if ($order[$jayden] eq $fieldNames[$kaya]) {
							next KAYA;
						}
						if ($jayden == @order-1) {
							die 'ERROR: "Order" statement on line '.($i+2).' does not match the list of names of captured fields. Should contain same items in any order: '."@fieldNames\n";
						}
					}
				}
				$globalDeclarations .= 'my @fieldNames = (\''. join ("','",@order) .'\');'."\n"
						      .'my %chewFieldInitiations;'."\n".'foreach (@fieldNames) { $chewFieldInitiations{$_} = 0; }'."\n";
				$i++;
			} else {
				die 'ERROR: "Outputting" must be followed by "Order" on line '.($i+2).".\n";
			}
		} else {
			die 'ERROR: Premature end of file. "Outputting" must be followed by "Order".'."\n";
		}
	} else {
		die 'ERROR: Line '.($i+1).' did not match any expected expression (Reframe, Starting, Stopping, Skipping, Matching, Locating, Splitting, Capture).'."\n";
	}
}
# CONSTRUCTING OUTPUT
my $outputPreparation = 'my $outputRowCount = 0;'."\n"
		       .'my $chewWarnings = "";'."\n"
		         .'foreach (@fieldNames) {'."\n"
		       .'  if ( $chewFieldInitiations{$_} ) {'."\n"
		       .'    if ( $outputRowCount != 0 && $outputRowCount != @{ $capturedData{$_} } ) {'."\n"
		       .'      $chewWarnings .='."\n"
		       .'		   "WARNING: Output column \"$_\" has a different length than a previous column.\n";'."\n"
		       .'    }'."\n"
		       .'    if ( $outputRowCount < @{ $capturedData{$_} } ) {'."\n"
		       .'      $outputRowCount = @{ $capturedData{$_} };'."\n"
		       .'    }'."\n"
		       .'  } else {'."\n"
		       .'    $chewWarnings .= "\nWARNING: Output column \"$_\" contains no data.\n";'."\n"
		       .'  }'."\n"
		       .'}'."\n";
my $outputStatement = '';
if ($outputFormat) {
	$outputStatement =   'my @chewOutputLines;'."\n"
			       .'for (my $i = 0; $i < $outputRowCount; $i++) {'."\n"
			       .$dropInsert
			       .'	$chewOutputLines[$i] = "";'."\n"
			       .'	foreach (@fieldNames) {'."\n"
			       .'		if ( defined( ${ $capturedData{$_} }[$i] ) ) {'."\n"
			       .'			$chewOutputLines[$i] .= ${ $capturedData{$_} }[$i];    }'."\n"
			       .'		$chewOutputLines[$i] .= "\t";'."\n"    #prevent column slippage by inserting tab even if no data captured for this col
			       .$dropClosure
			       .'} }'."\n"
			       .'foreach (@fieldNames) { print "$_\t" }'."\n"
			       .'print "\n";'."\n"
			       .'foreach (@chewOutputLines) { if ($_) { print "$_\n" } }'."\n";
}
my $warnLine =	     'warn $chewWarnings if $chewWarnings;'."\n";
my $output = $preamble1.$globalDeclarations.$preamble2.$bracketOpener.$stoppingStatement.$startingStatement.$skippingStatement.$closingBrackets.$outputPreparation.$outputStatement.$nonChewCode.$warnLine.$funcStr;

# adding required subroutines
if ($output =~ /completeURLchew/) {
	$output .= "\n".
'sub completeURLchew {
	if ($_[0] =~ /^https?\:\/\//) {
		return $_[0];
	} elsif ($_[0] =~ /^\//) {
		my @chars = split //, $_[1];
		my $foundDoubles = 0;
		for (my $i = 1; $i < @chars; $i++) {
			if (!$foundDoubles) {
				if ($chars[$i-1] eq "/" && $chars[$i] eq "/") {
					$foundDoubles = 1;
				}
			} else {
				if ($chars[$i] eq "/") {
					my $server = join "", @chars[0..($i-1)];
					return $server.$_[0];
				}
			}
		}
	} elsif ($_[0] =~ /^\.\./) {
	} elsif ($_[0] =~ /^\./) {
	} else {
		my $originalURL = $_[1];
		$originalURL =~ s/(^\/)*$//;
		return ($originalURL.$_[0]);
	}
}'."\n";		#TODO add support for relative URLs starting with dots
}

dispatch($outputProgLang,$outputFormat,$output);

sub dispatch {
	my ($outputProgLang,$outputFormat,$output) = @_;
	if ($outputProgLang eq 'perl5') {
		print $output;
		print "\n";
	} elsif ($outputFormat eq 'tsv+header') { 
		eval $output;
	}
}
# PARSING FUNCTIONS
sub processSplit {
	my ($fieldnamep, $i, $splitNum, $linep, $indentp, $cycleThrough, $lineDeviation) = @_;
	my $startingAdd = '';
	if ($$linep[$i] =~ /\/$/) {
		my $regex = extractRegex('Splitting at',$$linep[$i]);
		my $iterationChunk;
		if ($cycleThrough eq 'chewLines') {
			$iterationChunk = '$'.$curVName.'+'.$lineDeviation;
		} else{
			$iterationChunk = $lineDeviation;
		}
		$splitNum++;
		#TODO consider catching the warning and passing it on to the user rather than using plain exists() - user might want to know capture failed here
		$startingAdd .= "\t".'if (exists($'.$cycleThrough.'['.$iterationChunk.']) && $'.$cycleThrough.'['.$iterationChunk.'] =~ /'.$regex.'/) {'."\n"
			       ."\t\t".'my @array'.$splitNum.' = split /'.$regex.'/, $'.$cycleThrough.'['.$iterationChunk.'];'."\n";
		($splitNum, my $takeChunkPerlCode, my $skipLines) = processTakeChunk($fieldnamep,($i+1), $splitNum, $linep, $indentp);
		$startingAdd .= $takeChunkPerlCode."\t}\n";
		return($splitNum,$skipLines,$startingAdd);
	} else {
		die 'ERROR: Illegal end to "Splitting" statement on line '.($i+1).", found: $$linep[$i]\n";
	}
}
sub processCleanChunk {
	my ($startLine,$linep,$indentp) = @_;
	my @cleanExpressions;
	my $chunkLength = 0;
	for (my $i = $startLine; $i < @$linep; $i++) {
		if      ($$linep[$i] =~ /^\s*Cleaning (up )?\//) {
			die 'ERROR: Illegal end to "Cleaning" statement on line '.($i+1).", found: $$linep[$i]\n" unless $$linep[$i] =~ /\/$/;
			$chunkLength++;
			my $cleanStatement = $$linep[$i];
			$cleanStatement =~ s/^\s+Cleaning (up )?//;
			if ($$linep[$i+1] =~ /^\s+Replace with /) {
				my $replacement = $$linep[$i+1];
				$replacement =~ s/^\s+Replace with //;
				if ($replacement =~ /^\'/ && $replacement =~ /\'\s*$/) { #TODO count quote marks and warn if != 2
					$replacement =~ s/^\'//;
					$replacement =~ s/\'\s*$//;
				}
				$cleanStatement .= $replacement.'/';
				$chunkLength++;
				$i++;
			} else {
				die 'ERROR: "Cleaning" must be followed by "Replace" on line'.($i+2).".\n";
			}
			push @cleanExpressions, $cleanStatement;
		} elsif ($$linep[$i] =~ /^\s+Clean (up )?\//) {
			die 'ERROR: Illegal end to "Clean" statement on line '.($i+1).", found: $$linep[$i]\n" unless $$linep[$i] =~ /\/$/;
			$chunkLength++;
			my $cleanStatement = $$linep[$i];
			$cleanStatement =~ s/^\s+Clean (up )?//;
			$cleanStatement .= '/';
			push @cleanExpressions, $cleanStatement;
		} else {
			return ($chunkLength, @cleanExpressions);
		}
	}
}
sub processTakeChunk {
	my ($fieldnamep,$startLine,$splitNum,$linep,$indentp) = @_;
	my $outputVal = '';
	my $chunkLength = 0;
	for (my $i = $startLine; $i < @$linep; $i++) {
		last if ($$indentp[$i] < $$indentp[$startLine]);
		$chunkLength++;
		if ($$linep[$i] =~ /^\s*Take [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			my @array = split /Take | as /, $$linep[$i];
			checkInFieldname($fieldnamep,$array[2]);
			$outputVal .= "\t\t".'$chewFieldInitiations{'.$array[2].'}++ if defined($array'.$splitNum.'['.$array[1].']);'."\n"
				     ."\t\t".'push @{ $capturedData{'.$array[2].'} }, $array'.$splitNum.'['.$array[1].'] if defined($array'.$splitNum.'['.$array[1].']);'."\n";
		} elsif ($$linep[$i] =~ /^\s*Taking [0-9]+ as [A-Za-z][A-Za-z0-9]*$/) {
			unless ( $$indentp[$i+1] == $$indentp[$i]+1
			      && $$linep[$i+1]   =~ /^\s+Clean(ing)? (up)? \//
			      && $$linep[$i+1]   =~ /\/$/            ) {
				die 'ERROR: "Taking [...] as" on line '.$i.' must be "Take" or followed by "Clean up" statement.'."\n";
			}
			my @array = split /Taking | as /, $$linep[$i];
			checkInFieldname($fieldnamep,$array[2]);
			my ($skipLines, @cleanLines) = processCleanChunk(($i+1), $linep, $indentp);
			$i += $skipLines;
			$outputVal .= "\t\t".'if (defined($array'.$splitNum.'['.$array[1].'])) {'."\n";
			foreach (@cleanLines) {
				$outputVal .= "\t\t\t".'$array'.$splitNum.'['.$array[1].'] =~ s'.$_."g;\n"; # NB substitution is currently global by default!
			}
			$outputVal .= "\t\t\t".'$chewFieldInitiations{'.$array[2].'}++;'."\n"
				     ."\t\t\t".'push @{ $capturedData{'.$array[2].'} }, $array'.$splitNum.'['.$array[1].'];'."\n\t\t}\n";
		} elsif ($$linep[$i] =~ /^\s*Taking [0-9]+$/) {	    # TODO allow "At " as an alternative?
			my $wantedLine = $$linep[$i];
			$wantedLine =~ s/^\s*Taking //;
			if ($$linep[$i+1] =~ /^\s+Splitting at /) {
				($splitNum,my $splitChunkLength,my $newStartingAdd) = processSplit($fieldnamep,($i+1),$splitNum,$linep,$indentp,'array'.$splitNum,$wantedLine);
				$outputVal .= $newStartingAdd;
				$i += $splitChunkLength+1;
			}
		} elsif ($$linep[$i] =~ /^\s*Follow [0-9]+$/) {
			# TODO switch to http(s) mode if you're in local file mode and encounter http(s) to follow
			my $findex = $$linep[$i];
			$findex =~ s/^\s*Follow //g;
			my $condInsert = '';
			my $iterInsert   = '';
			if ($$linep[$i+1] =~ /^\s+(Times|Limit) [0-9]*$/) {
				my $times = $$linep[$i+1];
				$times =~ s/^\s*(Times|Limit) //;
				$i++;
				$globalDeclarations .= 'my $followTimes = 0;'."\n";
				$condInsert .= '$followTimes < '.$times.' && ';
				$iterInsert .= "\t\t\t".'$followTimes++;'."\n";
			}
			$outputVal .= "\t\t".'if ('.$condInsert.'defined($array'.$splitNum.'['.$findex.'])) {'."\n"
				     .$iterInsert
				     ."\t\t\t".'push @fileList, completeURLchew($array'.$splitNum.'['.$findex.'], $fileList[0]);'."\n"  #TODO eliminate need to assume that $fileList[0] is a proper URL
				     ."\t\t".'}'."\n";   # easier to read
		# TODO implement Cutting
		} else {
			die 'ERROR: Correctly formatted Take statement expected on line '.($i+1).", found: $$linep[$i]\n";
		}
	}
	return ($splitNum, $outputVal, $chunkLength);
}
sub processAtChunk {
	# "Locating" bracket can include Splitting, Capture, Cutting, others? 
	my ( $fieldnamep, $startLine, $splitNum, $curVName, $linep, $indentp ) = @_;
	my $outputVal = '';
	unless ($$linep[$startLine] =~ /^\s+At ([+-]?[1-9]\d*|0)$/) {
		die 'ERROR: At statement expected on line '.($startLine+1).".\n";
	}
	for (my $i = $startLine; $i < @$linep; $i++) {
		last if $$indentp[$i] < $$indentp[$startLine];
		if ($$linep[$i] =~ /^\s*(At) /) {	#TODO needs Take or Capture possibility
			my $lookWhere = $$linep[$i];
			$lookWhere =~ s/^\s*At //;
			for (my $j = $i+1; $j < @$linep; $j++) {
				if ($$indentp[$j] > $$indentp[$i]) {
					if ($$linep[$j] =~ /^\s*Splitting /) {
						($splitNum, my $skipLines, my $startingAdd) = processSplit($fieldnamep,$j,$splitNum,\@lines,\@indentDepth,'chewLines',$lookWhere);
						$outputVal .= $startingAdd;
						$j += $skipLines;
					}
				# TODO implement Cutting
				} else {
					$i = $j - 1;
					last;
				}
			}
		} else {
			die 'ERROR: "Locating" or "Looking" on line '.($i+1).' must be followed by "At" statements, instead found: '."$$linep[$i]\n";
		}
	}
	return ($outputVal,$splitNum);
}
sub processReframe {
	my $continue = $_[0];
	my $regex = $_[1];
	my $retStr = 'my @chewNewLines;
foreach my $line (@chewLines) {
	$line =~ s'.$regex.'g;
	my @array = split /\n/, $line;
	push @chewNewLines, @array;
}'."\n";
	if ($continue) {
		return $retStr.'@chewLines = @chewNewLines;'."\n";
	} else {
		return $retStr.'foreach (@chewNewLines) { print $_."\n"; }'."\n";
	}
}
# AUXILIARY FUNCTIONS
sub extractRegex {
	$_[1] =~ s/^\s*$_[0] \///;
	$_[1] =~ s/\/$//;
	return sanitiseRegex($_[1]);
}
sub sanitiseRegex {	# makes sure there are no single / in the middle of a regex that would escape it
	my @chars = split //, $_[0];
	if ($chars[0] eq '/') {
		$chars[0] = '\/';
	}
	my @active;
	for (my $i = 0; $i < (@chars-1); $i++) {
		if ($chars[$i] =~ /\\/ && $chars[$i+1] =~ /^\\$/) {
			$active[$i] = 0;
			$active[$i+1] = 0;
			$i++;
		} else {
			$active[$i] = 1;
		}
	}
	for (my $i = 1; $i < @chars; $i++) {
		if ($chars[$i] eq '/') {
			unless ($active[$i-1] == 1 && $chars[($i-1)] =~ /^\\$/ ) {
				$chars[$i] = '\/';
			}
		}
	}
	return (join ('', @chars));
}
sub expandToPerlFilelistStringRecur {
	my @tempArray;
	my @subparts = split /\.\./, $_[0];
	my $targetLength = length($subparts[0]);
	$subparts[0] =~ s/^0+//;
	$subparts[1] =~ s/^0+//;
	if ($subparts[0] > $subparts[1]) {
		die "Read file ranges must be in ascending order.\n";
	}
	for (my $a = $subparts[0]; $a < $subparts[1]+1; $a++) {
		while ( length($a) < $targetLength ) {
			$a = "0".$a;
		}
		push @tempArray, $a.$_[1];
	}

	if (@_ > 2) {
		my @returnedList = expandToPerlFilelistStringRecur(@_[2..(@_-1)]);
		my @resultArray;
		foreach my $left (@tempArray) {
			foreach my $right (@returnedList) {
				push @resultArray, $left.$right;
			}
		}
		return @resultArray;
	} else {
		return @tempArray;
	}
}
sub expandToPerlFilelistString {
	my @variablePartsArray;
	if ($_[0] =~ /\{\{[0-9]+\.\.[0-9]+\}\}/) {
		my @parts = split /\{\{|\}\}/, $_[0];
		my @results = expandToPerlFilelistStringRecur(@parts[1..(@parts-1)]);
		my $retString = '';
		foreach my $result (@results) {
			$retString .= '"'.$parts[0].$result.'", ';
		}
		chop $retString; chop $retString;
		return $retString;
	} elsif ($_[0] =~ /\{\{|\}\}/){
		warn "ADVISORY: Double curly brackets found in URL or file name that might be incomplete syntax. Proceeding anyway.\n";
	} else {
		return "'".$_[0]."'";
	}
}
sub checkInFieldname {
	my ($fieldnamep,$value) = @_;
	foreach (@$fieldnamep) {
		if ($_ eq $value) {
			warn "WARNING: Field name $value used more than once.\n";
			return;
		}
	}
	push @$fieldnamep, $value;
}
sub checkFieldExistsForDrop {
	my ($fieldnamep,$value) = @_;
	foreach (@$fieldnamep) {
		if ($_ eq $value) {
			return $value;
		}
	}
	die "ERROR: Unknown field $value specified in drop/remove/delete condition. The field must already be known before a condition can be placed on it.\n";
}
